<report
    title="Autofeed occurrences for Elasticsearch associations (standard filters)"
    description="A list of occurrence association details designed for feeding into Elasticsearch or a similar JSON store."
>
  <query website_filter_field="o.website_id" samples_id_field="o.sample_id" training_filter_field=""
         standard_params="occurrences" count_field="o.*" blocked_sharing_tasks_field="o.blocked_sharing_tasks">
DROP TABLE IF EXISTS oa_chunk;

SELECT distinct greatest(oa.updated_on, o1.updated_on, o2.updated_on) AS updated_on,
  oa.id, oa.from_occurrence_id,
  oa.to_occurrence_id,
  ctt.term AS association_type
INTO temporary oa_chunk
FROM occurrence_associations oa
  JOIN cache_termlists_terms ctt ON ctt.id=oa.association_type_id
  JOIN cache_occurrences_functional o1 ON o1.id=oa.from_occurrence_id
  JOIN cache_occurrences_functional o2 ON o2.id=oa.to_occurrence_id
  WHERE oa.deleted=false
  AND greatest(oa.updated_on, o1.updated_on, o2.updated_on) &lt; (
     select max(updated_on) from  cache_occurrences_functional
    WHERE tracking &lt; (select (value::json#>>'{0,last_tracking_id}')::integer  from  variables WHERE name='rest-autofeed-BRC5')
  )
  AND greatest(oa.updated_on, o1.updated_on, o2.updated_on) >= '#autofeed_tracking_date_from#'
  ORDER BY greatest(oa.updated_on, o1.updated_on, o2.updated_on)
   LIMIT 10000/2;

SELECT ch.from_occurrence_id as "id",
ch.updated_on  as  tracking_date,
ch.updated_on  as  tracking,
string_agg(DISTINCT oa.to_occurrence_id::text || '~' || ch.association_type || '~' || cttl.preferred_taxon || '~' || COALESCE(cttl.default_common_name, ''), '@@')  as  "associations_data"
  FROM oa_chunk ch
  JOIN occurrence_associations oa on oa.from_occurrence_id=ch.from_occurrence_id
  JOIN cache_occurrences_functional o ON o.id=oa.to_occurrence_id
  #agreements_join#
  JOIN cache_taxa_taxon_lists cttl on cttl.id=o.taxa_taxon_list_id
  WHERE ch.from_occurrence_id &gt; #last_id#
  #filters#
GROUP BY ch.from_occurrence_id, ch.updated_on
UNION
SELECT ch.to_occurrence_id  as  "id",
ch.updated_on  as  tracking_date,
ch.updated_on  as  tracking,
string_agg(DISTINCT oa.from_occurrence_id::text || '~&lt;&lt;' || ch.association_type || '~&lt;&lt;~' || cttl.preferred_taxon || '~' || COALESCE(cttl.default_common_name, ''), '@@')  as  "associations_data"
  FROM oa_chunk ch
  JOIN occurrence_associations oa on oa.to_occurrence_id=ch.to_occurrence_id
  JOIN cache_occurrences_functional o ON o.id=oa.from_occurrence_id
  #agreements_join#
  JOIN cache_taxa_taxon_lists cttl on cttl.id=o.taxa_taxon_list_id
  WHERE ch.to_occurrence_id &gt; #last_id#
  #filters#
GROUP BY ch.to_occurrence_id, ch.updated_on
  </query>
  <order_bys>
    <order_by>id ASC</order_by>
  </order_bys>
  <params>
    <param name="last_id" display="Last ID" datatype="integer" default="0" />
    <param name="autofeed_tracking_date_from" datatype="date" default="1900-01-01" />
    <param name="occurrences_autofeed_proj_id" display="Occurrences autofeed project" datatype="text"
      description="ID of a project configured in the REST API which feeds the occurrence data into Elasticsearch.
        Data from this feed will be processed before the associations" />
  </params>
  <columns>
    <column name="id" datatype="integer" />
    <column name="tracking_date" datatype="date" />
    <!-- tracking required for order by -->
    <column name="tracking" datatype="date" />
    <column name="associations_data" aggregate="true" />
  </columns>
</report>